A comparison of waterfall and agile methodologies

Agile and Waterfall are methodologies used in software development. They are fundamentally different; Agile was designed to rectify Waterfalls shortcomings (such as implementing changes; near impossible with Waterfall, but very easy with Agile). This essay explores some of the differences between the two.
In terms of structure, the two methodologies are complete opposites. Agile consists of “incremental, iterative work cadences” [1] called sprints (sections of time often 2-4 weeks in length whereby a set of tasks is decided, worked upon and reviewed). Waterfall (aka “linear-sequential life cycle model” [2]) is linear; there are multiple phases (requirements, design, implementation, verification, maintenance) which cannot overlap; the previous phase must be completed before the next can start. These phases often have ‘phase gates’ in-between (e.g. requirements being reviewed and approved before design can begin).
Another difference is the level of stakeholder/customer involvement.  With Agile, stakeholders are consulted at least once during every sprint, either during planning or review (a sprint review is called a “retrospective”; reviewing tickets is called “refinement”). This hands on approach can them give “a strong sense of ownership” [3] and a thorough understanding of the product, but may not suit stakeholders who “may not have the time or interest for this type of participation.”[3] In Waterfall development the stakeholders are consulted at the beginning when discussing requirements, then shown the final product at the end (“except for reviews, approvals, status meetings, etc., a customer presence is not strictly required after the requirements phase.” [3]) which may cause issues if the final delivered software is not as expected.
The ease of amending the project mid-development varies with the method used. A Waterfall project may be doomed if the initial requirements (which it relies heavily on) are faulty in any manner. (“If a requirement error is found, or a change needs to be made, the project has to start from the beginning with all new code.” [4]). Once testing has started amendments are almost impossible to make without disrupting all other completed phases; there’s no method to work backwards. If a bug is found the entire process must be restarted to create a fix. With Agile the project is reviewed at the end of each sprint; any bugs discovered are immediately placed into the sprint backlog to be dealt with, and customers are consulted to ensure the project remains on track. This allows for changes to be easily incorporated, and any issue to be ironed out. “Agile methods are more flexible than the waterfall method which means that customers’ requests are more likely to be met” [5]. However, Agile lacks definitive planning; the final deliverable may be fairly different from what was initially intended.
Team members in Agile and Waterfall differ in the number of roles they play; “Agile teams are formed (mostly) of generalizing specialists… someone who has one or more technical specialties (e.g. Java programming, project management, database administration…)” [6]. In Agile, if someone is working on a particular task and has become stuck, they should be able to call on any member of the team to provide (at least some) basic assistance. This makes the team much more fluid as a whole, and the chance of completing tasks increases. Waterfall teams consist of people that perform only their dedicated role. However this doesn’t mean they’re sat idly when their phase is complete; “it’s possible for various members of the team to be involved or to continue with other work, depending on the active phase of the project.”[3] In both methodologies team members can be lent from one team to another.
Deciding which methodology to use comes down to the type of project. Agile is modular development; well suited to object-oriented projects with various different features and requirements. However Agile may lose its way with large projects/organisations and “introduce extra inefficiencies” [5]. Waterfall works great with small projects with clearly defined requirements and a well thought out plan, where the likelihood of deviation is low.
Agile puts an emphasis on speed; throughout development there are many, small releases (a working piece of software could be delivered after a single sprint; “because the products are tested so thoroughly with Agile, the product could be launched at the end of any cycle” [4]). The lack of real documentation in Agile isn’t so much of an issue when the customer can step in at almost any point and put a hold to features they deem unworthy, or suggest new features. In contrast, Waterfall emphasises record keeping (the entire project is pre-planned and the plan followed during each phase; “At the end of each phase, a review takes place to determine if the project is on the right path and whether or not to continue or discard the project” [2]). This is needed as Waterfall has only one main release, at the end of the project lifecycle. If the planning wasn’t performed thoroughly enough, the end product will almost certainly not meet requirements, and the customer will be unhappy.

Bibliography
[1]: http://agilemethodology.org/
[2]: http://istqbexamcertification.com/what-is-waterfall-model-advantages-disadvantages-and-when-to-use-it/
[3]: http://www.seguetech.com/blog/2013/07/05/waterfall-vs-agile-right-development-methodology
[4]: http://www.base36.com/2012/12/agile-waterfall-methodologies-a-side-by-side-comparison/
[5]: http://manifesto.co.uk/agile-vs-waterfall-comparing-project-management-methodologies/
[6]: http://www.ambysoft.com/essays/agileRoles.html 
